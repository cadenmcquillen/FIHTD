---
title: "group5_FIHTD_HW3"
author: "Caden McQuillen, Yuchen Sun, Xiang (Jennie) Li"
date: '2023-03-20'
output:
  html_document:
    toc: yes
---


## Libraries
```{r message=FALSE}
library(tidyverse)
library(ggplot2)
```

## 1. The human diseasome

### 1.1 Load expression data
```{r}
data <- load("Diseasome_preprocessed.Rdata")
diseasome
```

The data frame `diseasome` is the Human Diseasome in __edge list__ format (the first two columns are indices into the disease and gene list, respectively). How many diseases and genes are in the Diseasome? How many edges do you see?

```{r}
num_diseases <- length(unique(diseasome[,1]))
num_genes <- length(unique(diseasome[,2]))
num_edges <- nrow(diseasome)

cat("num diseases:", num_diseases, "\n")
cat("num genes:", num_genes, "\n")
cat("num edges:", num_edges, "\n")
```


### 1.2
Transform the loaded edge list into a matrix, where rows correspond to diseases, columns to genes, and an entry to whether an edge exists between the respective disease and gene. What are the dimensions of the matrix?

```{r}
# Create a sparse matrix 
diseasome_mat <- sparseMatrix(
                      i=diseasome[,1], j=diseasome[,2], # disease indices & gene indices
                      dims=c(max(diseasome[,1]), max(diseasome[,2])),
                      dimnames=list(unique(diseasome[,1]), unique(diseasome[,2])))

diseasome_matrix <- as.matrix(diseasome_mat)

dim(diseasome_matrix)
```


### 1.3 Generate HDN
Generate the Human Disease Network (HDN, Figure 1 in Goh et al.) by multiplying the matrix with its own transpose, see lecture. What are the dimensions of the HDN matrix? What are the numeric values in the matrix?

```{r}
hdn <- t(diseasome_mat) %*% diseasome_mat
hdn_matrix <- as.matrix(hdn)
dim(hdn)
```

### 1.4 Visualize the HDN
In addition, show a detailed subnetwork of your choice.

```{r}
library(igraph)

# Create a graph object from the HDN matrix
hdn_graph <- graph.adjacency(hdn_matrix, weighted=TRUE, mode="upper")

# Set vertex labels to disease names
V(hdn_graph)$label <- V(hdn_graph)$name

# Set vertex size based on degree
V(hdn_graph)$size <- degree(hdn_graph)

# Set edge color based on weight
E(hdn_graph)$color <- rgb(0,0,0,alpha=0.5*E(hdn_graph)$weight/max(E(hdn_graph)$weight))

# Plot the graph
plot(hdn_graph, layout=layout_with_fr)
```



## 2. Pathway GGMs
### Load data
```{r}
load("QMDiab_preprocessed_data_withggm.RData")
```

### Eigenmetabolites for subpathways and partial correlation 
```{r}


#eigenmetabolite for subpathways
zdat <- scale(dat) # scale dat to have mean=0 and sd=1 for each column (metabolites)
unique_sub_pathways <- na.omit(unique(annotations$SUB_PATHWAY)) # get all subpathways and remove NAs
df_sub <- data.frame(matrix(nrow=length(T2D),ncol=length(unique_sub_pathways))) # create empty data frame for pathway representatives
colnames(df_sub) <- unique_sub_pathways # assign colnames as pathway names
expvars_sub <- c()
for (p in unique_sub_pathways) {
  metab <- annotations[which(annotations$SUB_PATHWAY==p), 2] # identify metabs that belong to pathway
  use_zdat <- zdat[,colnames(zdat) %in% metab$BIOCHEMICAL] # get data of the metabs
  pca <- prcomp(use_zdat) # perform pca
  expvar <- (pca$sdev^2)/sum(pca$sdev^2)
  expvars_sub <- c(expvars_sub, expvar[1])
  df_sub[p] <- pca$x[,1] # add first pca coordinate as pathway representative to df
}


#Calculate partial correlations
sub_pathway_pcor <- pcor(df_sub)


#Multi testing correction
alpha = 0.05 

#copy DE dataframe 
sub_pathway_pcor_adj <- sub_pathway_pcor
#boneferroni
num_pathways <- length(colnames(df_sub))
num_test <- (((num_pathways *num_pathways )-num_pathways )/2)
sub_pathway_pcor_adj$p.adj <- (sub_pathway_pcor_adj$p.value)*num_test

#replace correlation matrix with 0s for not significant entries and along diagonal
sub_pathway_pcor_adj$estimate[sub_pathway_pcor_adj$p.adj > 0.05] <- 0
sub_pathway_pcor_adj$estimate[diag(sub_pathway_pcor_adj$estimate)] <- 0


#Convert correlations to all positive
sub_pathway_pcor_adj$estimate <- abs(sub_pathway_pcor_adj$estimate)

g <- simplify(graph.adjacency(sub_pathway_pcor_adj$estimate,mode="undirected",weighted=T,diag=F))

plot.igraph(g,vertex.size=degree(g)+2,vertex.label=NA,edge.width=abs(E(g)$weight),layout=layout.auto(g))

```

## 3. Phenotype-driven module identification
