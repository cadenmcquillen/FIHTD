---
title: "group5_FIHTD_HW3"
author: "Caden McQuillen, Yuchen Sun, Xiang (Jennie) Li"
date: '2023-03-20'
output:
  html_document:
    toc: yes
---


## Libraries
```{r message=FALSE}
library(tidyverse)
library(ggplot2)
library(Matrix)
library(igraph)
library(ppcor)
```

## 1. The human diseasome

### 1.1 Load expression data
```{r}
data <- load("Diseasome_preprocessed.Rdata")
head(diseasome)
```

The data frame `diseasome` is the Human Diseasome in __edge list__ format (the first two columns are indices into the disease and gene list, respectively). How many diseases and genes are in the Diseasome? How many edges do you see?

```{r}
num_diseases <- length(unique(diseasome[,1]))
num_genes <- length(unique(diseasome[,2]))
num_edges <- nrow(diseasome)

cat("num diseases:", num_diseases, "\n")
cat("num genes:", num_genes, "\n")
cat("num edges:", num_edges, "\n")
```


### 1.2
Transform the loaded edge list into a matrix, where rows correspond to diseases, columns to genes, and an entry to whether an edge exists between the respective disease and gene. What are the dimensions of the matrix?

```{r}
# Create a sparse matrix 
diseasome_mat <- sparseMatrix(
                      i=diseasome[,1], j=diseasome[,2], # disease indices & gene indices
                      dims=c(max(diseasome[,1]), max(diseasome[,2])),
                      dimnames=list(unique(diseasome[,1]), unique(diseasome[,2])))
colnames(diseasome_mat) <- genes_names$Gene.symbols 
rownames(diseasome_mat) <- diseases_names$Disorder.name
diseasome_matrix <- as.matrix(diseasome_mat)
dim(diseasome_matrix)
```


### 1.3 Generate HDN
Generate the Human Disease Network (HDN, Figure 1 in Goh et al.) by multiplying the matrix with its own transpose, see lecture. What are the dimensions of the HDN matrix? What are the numeric values in the matrix?

```{r}
hdn <-  diseasome_mat %*% t(diseasome_mat)
hdn_matrix <- as.matrix(hdn)
colnames(hdn_matrix) <- diseases_names$Disorder.name
rownames(hdn_matrix) <- diseases_names$Disorder.name
dim(hdn)
```

### 1.4 Visualize the HDN
In addition, show a detailed subnetwork of your choice.

```{r}
# Create a graph object from the HDN matrix
hdn_graph <- graph.adjacency(hdn_matrix,weighted=TRUE,mode="upper",diag=F)
hdn_graph <- delete.vertices(hdn_graph,degree(hdn_graph)==0)

# Set vertex labels to disease names
V(hdn_graph)$label <- V(hdn_graph)$name

# Set vertex size based on degree
V(hdn_graph)$size <- degree(hdn_graph)

# Set edge color based on weight
E(hdn_graph)$color <- rgb(0,0,0,alpha=0.5*E(hdn_graph)$weight/max(E(hdn_graph)$weight))
```

```{r}
# Plot the graph
plot.igraph(hdn_graph,vertex.size=degree(hdn_graph),vertex.label=NA,edge.width=abs(E(hdn_graph)$weight),layout=layout.auto(hdn_graph))
```
### Basal cell carcinoma Subnetwork
```{r}
#get index of bcc
bcc_index <- which(diseases_names$Disorder.name == "Basal cell carcinoma (3)")
#get edges of HDN for bcc
bcc_edges <- which(hdn_matrix[,bcc_index] == 1)

bcc_matrix <- hdn_matrix[bcc_edges, bcc_edges]


# Create a graph object from the bcc matrix
bcc_graph <- graph.adjacency(bcc_matrix,weighted=TRUE,mode="upper",diag=F)


# Set vertex labels to disease names
V(bcc_graph)$label <- V(bcc_graph)$name

# Set vertex size based on degree
V(bcc_graph)$size <- degree(bcc_graph)

# Set edge color based on weight
E(bcc_graph)$color <- rgb(0,0,0,alpha=0.5*E(bcc_graph)$weight/max(E(bcc_graph)$weight))
```

```{r}
# Plot the graph
plot.igraph(bcc_graph,vertex.size=degree(bcc_graph),vertex.label=V(bcc_graph)$label,edge.width=abs(E(bcc_graph)$weight),layout=layout.auto(bcc_graph))

```


## 2. Pathway GGMs
### Load data
```{r}
load("QMDiab_preprocessed_data_withggm.RData")
```

### Eigenmetabolites for subpathways and partial correlation 
```{r}
#eigenmetabolite for subpathways
zdat <- scale(dat) # scale dat to have mean=0 and sd=1 for each column (metabolites)
unique_sub_pathways <- na.omit(unique(annotations$SUB_PATHWAY)) # get all subpathways and remove NAs
df_sub <- data.frame(matrix(nrow=length(T2D),ncol=length(unique_sub_pathways))) # create empty data frame for pathway representatives
colnames(df_sub) <- unique_sub_pathways # assign colnames as pathway names
expvars_sub <- c()
for (p in unique_sub_pathways) {
  metab <- annotations[which(annotations$SUB_PATHWAY==p), 2] # identify metabs that belong to pathway
  use_zdat <- zdat[,colnames(zdat) %in% metab$BIOCHEMICAL] # get data of the metabs
  pca <- prcomp(use_zdat) # perform pca
  expvar <- (pca$sdev^2)/sum(pca$sdev^2)
  expvars_sub <- c(expvars_sub, expvar[1])
  df_sub[p] <- pca$x[,1] # add first pca coordinate as pathway representative to df
}


#Calculate partial correlations
sub_pathway_pcor <- pcor(df_sub)


#Multi testing correction
alpha = 0.05 

#copy DE dataframe 
sub_pathway_pcor_adj <- sub_pathway_pcor
#boneferroni
num_pathways <- length(colnames(df_sub))
num_test <- (((num_pathways *num_pathways )-num_pathways )/2)
sub_pathway_pcor_adj$p.adj <- (sub_pathway_pcor_adj$p.value)*num_test

#replace correlation matrix with 0s for not significant entries and along diagonal
sub_pathway_pcor_adj$estimate[sub_pathway_pcor_adj$p.adj > 0.05] <- 0
sub_pathway_pcor_adj$estimate[diag(sub_pathway_pcor_adj$estimate)] <- 0


#Convert correlations to all positive
sub_pathway_pcor_adj$estimate <- abs(sub_pathway_pcor_adj$estimate)

g <- simplify(graph.adjacency(sub_pathway_pcor_adj$estimate,mode="undirected",weighted=T,diag=F))

plot.igraph(g,vertex.size=degree(g)+2,vertex.label=NA,edge.width=abs(E(g)$weight),layout=layout.auto(g))

```

### Eigenmetabolites for superpathways and partial correlation 
```{r}
#eigenmetabolite for subpathways
zdat <- scale(dat) # scale dat to have mean=0 and sd=1 for each column (metabolites)
unique_super_pathways <- na.omit(unique(annotations$SUPER_PATHWAY)) # get all superpathways and remove NAs
df_super <- data.frame(matrix(nrow=length(T2D),ncol=length(unique_super_pathways))) # create empty data frame for pathway representatives
colnames(df_super) <- unique_super_pathways # assign colnames as pathway names
expvars_super <- c()
for (p in unique_super_pathways) {
  metab <- annotations[which(annotations$SUPER_PATHWAY==p), 2] # identify metabs that belong to pathway
  use_zdat <- zdat[,colnames(zdat) %in% metab$BIOCHEMICAL] # get data of the metabs
  pca <- prcomp(use_zdat) # perform pca
  expvar <- (pca$sdev^2)/sum(pca$sdev^2)
  expvars_super <- c(expvars_super, expvar[1])
  df_super[p] <- pca$x[,1] # add first pca coordinate as pathway representative to df
}


#Calculate partial correlations
super_pathway_pcor <- pcor(df_super)


#Multi testing correction
alpha = 0.05 

#copy DE dataframe 
super_pathway_pcor_adj <- super_pathway_pcor
#boneferroni
num_pathways <- length(colnames(df_super))
num_test <- (((num_pathways *num_pathways )-num_pathways )/2)
super_pathway_pcor_adj$p.adj <- (super_pathway_pcor_adj$p.value)*num_test

#replace correlation matrix with 0s for not significant entries and along diagonal
super_pathway_pcor_adj$estimate[super_pathway_pcor_adj$p.adj > 0.05] <- 0
super_pathway_pcor_adj$estimate[diag(super_pathway_pcor_adj$estimate)] <- 0


#Convert correlations to all positive
super_pathway_pcor_adj$estimate <- abs(super_pathway_pcor_adj$estimate)

g <- simplify(graph.adjacency(super_pathway_pcor_adj$estimate,mode="undirected",weighted=T,diag=F))

plot.igraph(g,vertex.size=degree(g)+2,vertex.label=NA,edge.width=abs(E(g)$weight),layout=layout.auto(g))

```

### Difference between our method and paper's method
In the paper a link is drawn between two super pathway's if there is at least 1 link between any two subpathways in each respective group. In our method we get the eigenmetabolite representative of each superpathway and then get the partial correlations between every super pathway where a link is drawn if there is statistically significant correlation between any two superpathways. 

## 3. Phenotype-driven module identification

### Reload dataset
```{r}
load("QMDiab_preprocessed_data_withggm.RData")
```

### Perform t-test
```{r}
t2d <- which(T2D==1)
nt2d <- which(T2D==0)
t2d_metab <- dat[t2d,]
nt2d_metab <- dat[nt2d,]

pvals <- c()
metab <- c()
idx <- c()

for (i in 1:length(colnames(dat))) {
  t2d_samp <- t2d_metab[,i] # t2d samples
  nt2d_samp <- nt2d_metab[,i] # non-t2d samples
  temp <- t.test(t2d_samp,nt2d_samp)
  pvals[i] <- temp$p.value
  metab[i] <- colnames(dat)[i]
  idx[i] <- i
}
```

### Multiple testing correction
```{r}
de <- data.frame(idx,metab,pvals)
names(de) <- c('index','metab','pvalue')
de$p.adj <- p.adjust(de$pvalue,method="fdr")
head(de)
```

### Module identification
```{r}
# identify all neighbor nodes
# get ids
neighbor_ids <- which(ggm[,345]>0)
neighbor_ids
# get ggm vals
neighbor_nodes <- ggm[neighbor_ids,345]
neighbor_nodes
# get names
neighbor_nodes_names <- names(neighbor_nodes)
neighbor_nodes_names

#get T2D pvalues for every neighbor
neighbor_pvalues <- de[which(de$metab %in% neighbor_nodes_names),]
neighbor_pvalues

#get T2D pvalue for seed
seed_pvalue <- de[which(de$index == 345),]
seed_pvalue
```
### Scale data and find best module
```{r}
zdat <- scale(dat)
t2d_zmetab <- zdat[t2d,]
nt2d_zmetab <- zdat[nt2d,]
module_pvals <- c()
module_names <- c()
module_id <- c()
module_val <- c()
for (i in 1:length(neighbor_nodes_names)) {
  zsamp_id <- neighbor_ids[i]
  if (zsamp_id != 345) {
    zsamp_val <- neighbor_nodes[i]
    t2d_zsamp <- t2d_zmetab[,zsamp_id]
    nt2d_zsamp <- nt2d_zmetab[,zsamp_id]
    temp <- t.test(t2d_zsamp,nt2d_zsamp)
    module_pvals[i] <- temp$p.value
    module_names[i] <- neighbor_nodes_names[i]
    module_id[i] <- zsamp_id
    module_val[i] <- zsamp_val
  }
}
```

```{r}
module_de <- data.frame(module_id,module_val,module_pvals,module_names)
names(module_de) <- c('module_id','module_ggm_val','module_pvalue','module_name')
module_de <- na.omit(module_de)
module_de

added <- module_de$module_name[module_de$module_pvalue==min(module_de$module_pvalue)]
cat("neighbor added to the module should be",added)
```
